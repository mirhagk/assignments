\newcommand{\code}{\texttt}

\documentclass{beamer}
%\usetheme{default}
%\usetheme{Boadilla}
%\usetheme{Madrid}
\usetheme{Pittsburgh}
%\usetheme{Rochester}
%\usetheme{Copenhagen}
%\usetheme{Warsaw}
%\usetheme{Singapore}
%\usetheme{Malmoe}
%\usecolortheme{albatross}

\usepackage{listings}

\title[RCImmix]{A Description of the RCImmix Algorithm}
\subtitle[RC]{Reference Counting with better heap allocation}
\author[N. Jervis]{Nathan Jervis}
\institute[McMaster]{
  Department of Computer Science\\
  McMaster University, Hamilton\\
  \texttt{jervisnd@mcmaster.ca}
}


\begin{document}


%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

%--- the presentation begins here ----------------%
\begin{frame}{Overview}
	\begin{itemize}
		\item Introduction to automatic memory management
		\item Problems with existing reference counting
		\item The RCImmix algorithm
	\end{itemize}
\end{frame}

\begin{frame}{Manual Memory Management}
	\textbf{Manual Memory Management}
	\begin{itemize}
		\item Difficult to use
		\item Can cause dangling pointers
		\item Leads to memory leaks
	\end{itemize}
	\emph{Much better if the compiler/runtime can manage memory for us}
\end{frame}

\begin{frame}{Automatic Memory Management}
	\textbf{Tracing Garbage Collector:}
	\begin{itemize}
		\item Periodically pause program and follow program references
		\item Collect anything not referred to
	\end{itemize}
	\textbf{Reference Counting:}
	\begin{itemize}
		\item Counter keeps track of how many things are pointing to it
		\item When counter reaches 0, free memory
	\end{itemize}
\end{frame}

\begin{frame}{Tracing Garbage Collector}
	\textbf{Pros:}
	\begin{itemize}
		\item Is lazy about collecting
		\item Can detect and collect all forms of garbage
		\item Can compact memory to improve cache performance
	\end{itemize}
	\textbf{Cons:}
	\begin{itemize}
		\item Requires pausing the program during collection
		\item Needs complete control over the memory
	\end{itemize}
\end{frame}

\begin{frame}{Reference Counting}
	\textbf{Pros:}
	\begin{itemize}
		\item Doesn't normally stall\footnote{Can still stall a bit if large chains are freed from a single decrement, ie with large linked lists}
		\item Memory gets released at precise, defined times (as soon as they have no more references to them)
	\end{itemize}
	\textbf{Cons:}
	\begin{itemize}
		\item Poor locality (poor cache performance)
		\item Increment/Decrement for all reference copying takes a non-insignificant amount of time.
		\item Can't detect cycles
	\end{itemize}
\end{frame}


\begin{frame}{Cycles}
	\begin{center}
		\includegraphics[width=75mm]{graphics/cycles.png}
	\end{center}
	\begin{itemize}
		\item A points to B
		\item B points to A
		\item only way A reach 0 is if B reaches 0
		\item since A points to B, B can't reach 0 until A does
		\item Reference Counting can't collect this
	\end{itemize}
\end{frame}

\begin{frame}{Initial Memory State}
	\begin{center}
		\includegraphics[width=\textwidth]{graphics/memState0.png}
	\end{center}
	\begin{itemize}
		\item Includes one cycle
		\item A is the root of the program %only one you have reference to
	\end{itemize}
\end{frame}
\begin{frame}{Initial Memory State}
	\begin{center}
		\includegraphics[width=\textwidth]{graphics/memState1.png}
	\end{center}
	\begin{itemize}
		\item A stops referring to 
		\item  B now has no references to it, and dies
	\end{itemize}
\end{frame}
\begin{frame}{Initial Memory State}
	\begin{center}
		\includegraphics[width=\textwidth]{graphics/memState2.png}
	\end{center}
	\begin{itemize}
		\item B is freed, and decrements the references it's pointing to
		\item D now has no references to it, and becomes dead
	\end{itemize}
\end{frame}
\begin{frame}{Initial Memory State}
	\begin{center}
		\includegraphics[width=\textwidth]{graphics/memState3.png}
	\end{center}
	\begin{itemize}
		\item D is freed, and decrements the references it's pointing to
		\item But F still has G pointing to it, so it doesn't get freed
		%Even though you can no longer access it
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Block Based Memory Allocation}
%\begin{frame}{Block Based Memory Allocation}
	Normally memory allocation involves maintaining a list of all free locations and selecting one.\\
	
	Block based memory allocation can allocate memory within a block by simply incrementing a pointer. Example:
\begin{lstlisting}[caption=Bump Pointer Memory Allocation]
function allocate(size)
    if pointer+size < block.length
        result = pointer
        pointer += size
        return result
    else
        block = getFreeBlock()
        pointer=0
\end{lstlisting}

\end{frame}

\begin{frame}{Block Based Memory Allocation}
	\begin{itemize}
		\item With a large enough block size, the majority of calls will simply increment the pointer.
		\item Avoids expensive free list walking
		\item Also sequential calls to memory allocator will allocate memory sequentially (great for cache)
		\pause
		\item requires entire blocks to be free before any item can be used
		\pause
		\item Okay for tracing collector (can move objects)
		\pause
		\item Not usable for reference counting
	\end{itemize}
\end{frame}

\begin{frame}{Ref. Counting Problems}
	\textbf{Summary of problems with reference counting:}
	\begin{itemize}
		\item Increment/Decrement can take up non-trivial amounts of time
		\item Allocation is much more expensive than tracing collectors
		\item Poor cache performance (bad locality)
		\item Can't detect cycles
		\item Requires an entire word to store counter reliably (32 bits for every object on current machines)
	\end{itemize}
\end{frame}

\begin{frame}{Introducing RCImmix}
	\textbf{RCImmix - reference counting on steroids}
	\begin{itemize}
		\item Builds upon serious of smaller optimizations
		\item Can detect cycles
		\item Can use block-based memory allocation
		\item Much better cache performance
		\item requires only a few bits to store counter (can even use existing space in object header)
	\end{itemize}
\end{frame}

\begin{frame}{RCImmix - Cycle Collection}
	\begin{itemize}
		\item Don't worry about cycles
		\item Will lead to unclaimed garbage
		\item Backup tracing collector
		\item Will eventually be discovered and collected
	\end{itemize}
\end{frame}

\begin{frame}{Performance Comparisons}
	Tracing Garbage collection can perform much faster than Reference counting for several reasons:
	\begin{itemize}
		\item Can free large chunks, and allocate memory by simply incrementing the pointer
	\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Memory Management}
%{Memory Management}[fragile]


\begin{lstlisting}[caption=First C example]
int main()
{
    printf("Hello World!");
    return 0;
}
\end{lstlisting}

A displayed formula:

\[
  \int_{-\infty}^\infty e^{-x^2} \, dx = \sqrt{\pi}
\]

An itemized list:

\begin{itemize}
  \item itemized item 1
  \item itemized item 2
  \item itemized item 3
\end{itemize}

\begin{theorem}
  In a right triangle, the square of hypotenuse equals
  the sum of squares of two other sides.
\end{theorem}

\end{frame}

\end{document}